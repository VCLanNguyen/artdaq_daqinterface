  daq: {
  fragment_receiver: {
    mpi_sync_interval: 50

    # CommandableFragmentGenerator Configuration: 
fragment_ids: []
fragment_id: -99 # Please define only one of these

sleep_on_stop_us: 0

requests_enabled: false # Whether to set up the socket for listening for trigger messages
request_mode: "Ignored" # Possible values are: Ignored, Single, Buffer, Window

data_buffer_depth_fragments: 1000
data_buffer_depth_mb: 1000

request_port: 3001
request_address: "227.128.12.26" # Multicast request address

request_window_offset: 0 # Request message contains tzero. Window will be from tzero - offset to tzero + width
request_window_width: 0
stale_request_timeout: "0xFFFFFFFF" # How long to wait before discarding request messages that are outside the available data
request_windows_are_unique: true # If request windows are unique, avoids a copy operation, but the same data point cannot be used for two requests. If this is not anticipated, leave set to "true"

separate_data_thread: false # MUST be true for triggers to be applied! If triggering is not desired, but a separate readout thread is, set this to true, triggers_enabled to false and trigger_mode to ignored.
separate_monitoring_thread: false # Whether a thread should be started which periodically calls checkHWStatus_, a user-defined function which should be used to check hardware status registers and report to MetricMan.
poll_hardware_status: false # Whether checkHWStatus_ will be called, either through the thread or at the start of getNext
hardware_poll_interval_us: 1000000 # If hardware monitoring thread is enabled, how often should it call checkHWStatus_


    # Generated Parameters: 
    generator: ToySimulator
    fragment_type: TOY1
    fragment_id: 0
    board_id: 0
    starting_fragment_id: 0
    random_seed: 3152
    sleep_on_stop_us: 500000 

    # Generator-Specific Configuration:
    
nADCcounts: 40

change_after_N_seconds: 5
#nADCcounts_after_N_seconds: -1
abort_after_N_seconds: true
#exit_after_N_seconds: true
#exception_after_N_seconds: true

throttle_usecs: 100000

distribution_type: 1

timestamp_scale_factor: 1

	destinations: {
	  d2: { transferPluginType: MPI destination_rank: 2 max_fragment_size_words: 2097152 host_map: [{rank: 0 host: "mu2edaq01.fnal.gov" portOffset: 5300},{rank: 1 host: "mu2edaq01.fnal.gov" portOffset: 5310},{rank: 2 host: "mu2edaq01.fnal.gov" portOffset: 5320},{rank: 3 host: "mu2edaq01.fnal.gov" portOffset: 5330},{rank: 4 host: "mu2edaq01.fnal.gov" portOffset: 5340},{rank: 5 host: "mu2edaq01.fnal.gov" portOffset: 5350}]}
d3: { transferPluginType: MPI destination_rank: 3 max_fragment_size_words: 2097152 host_map: [{rank: 0 host: "mu2edaq01.fnal.gov" portOffset: 5300},{rank: 1 host: "mu2edaq01.fnal.gov" portOffset: 5310},{rank: 2 host: "mu2edaq01.fnal.gov" portOffset: 5320},{rank: 3 host: "mu2edaq01.fnal.gov" portOffset: 5330},{rank: 4 host: "mu2edaq01.fnal.gov" portOffset: 5340},{rank: 5 host: "mu2edaq01.fnal.gov" portOffset: 5350}]}

	}
  }

  metrics: {
    brFile: {
      metricPluginType: "file"
      level: 3
      fileName: "/tmp/boardreader/br_%UID%_metrics.log"
      uniquify: true
    }
    # ganglia: {
    #   metricPluginType: "ganglia"
    #   level: %{ganglia_level}
    #   reporting_interval: 15.0
    # 
    #   configFile: "/etc/ganglia/gmond.conf"
    #   group: "ARTDAQ"
    # }
    # msgfac: {
    #    level: %{mf_level}
    #    metricPluginType: "msgFacility"
    #    output_message_application_name: "ARTDAQ Metric"
    #    output_message_severity: 0 
    # }
    # graphite: {
    #   level: %{graphite_level}
    #   metricPluginType: "graphite"
    #   host: "localhost"
    #   port: 20030
    #   namespace: "artdaq."
    # }
  }
}