BEGIN_PROLOG

component_pull_standard: {

   fragment_receiver: {

      generator: "ToySimulator"

        distribution_type: 3
        max_fragment_size_bytes: 1024000 # max_fragment_size_bytes should be set taking into account the value of nADCcounts (the number of 2-byte ADC counts)
        nADCcounts: 500000
        usecs_between_sends: 100000
        timestamp_scale_factor: 1

        fragment_type: "TOY2"

      # separate_data_thread MUST be true for requests to be applied! If requesting is not desired, but a separate readout thread is, set this to true, requests_enabled to false and request_mode to ignored.
      separate_data_thread: true 

      # separate_monitoring_thread defines whether a thread should be started which periodically calls checkHWStatus_(), a user-defined function which should be used to check hardware status registers and report to MetricMan.
      separate_monitoring_thread: false 

      # hardware_poll_interval_us is how often, in microseconds, checkHWStatus_() should be called. 0 to disable.
      hardware_poll_interval_us: 0 

      # See the artdaq file CommandableFragmentGenerator.hh for documentation on request_mode
      request_mode: "Window"

      # sleep_on_stop_us gives the stopping thread the chance to gather the required lock
      sleep_on_stop_us: 500000
      
      # end_of_run_quiet_timeout_ms is the time in milliseconds that the entire system must be quiet for check_stop to return true in request mode. 
      end_of_run_quiet_timeout_ms: 1000 

      # data_buffer_depth_fragments is the max fragments which can be stored within the boardreader before dropping occurs
      data_buffer_depth_fragments: 1000

      # data_buffer_depth_mb is the max cumulative size in megabytes of the fragments which can be stored within the boardreader before dropping occurs
      data_buffer_depth_mb: 1000

      # If request_mode is set to "Window", the window will be the request's timestamp - request_window_offset to timestamp - request_window_offset + request_window_width
      request_window_offset: 0 

      # If request_mode is set to "Window", the window will be the request's timestamp - request_window_offset to timestamp - request_window_offset + request_window_width
      request_window_width: 0 

      # Fragments stored in the fragment generator which are older than the newest stored fragment by at least stale_request_timeout units of request timestamp ticks will get discarded
      stale_request_timeout: "0xFFFFFFFF" 

      # If request_windows_are_unique, avoids a copy operation, but the same data point cannot be used for two requests. If this is not anticipated, leave set to "true"
      request_windows_are_unique: true  

      request_address: "999.999.999.999"       # Don't touch this; DAQInterface will set it

      destinations: {}

      #include "routing_for_boardreaders.fcl"
}

  #include "metrics_for_boardreaders.fcl"
}

component02_pull_standard: @local::component_pull_standard
component02_pull_standard.fragment_receiver.fragment_id: 2
component02_pull_standard.fragment_receiver.starting_fragment_id: 2
component02_pull_standard.fragment_receiver.board_id: 2
component02_pull_standard.fragment_receiver.random_seed: 2

component03_pull_standard: @local::component_pull_standard
component03_pull_standard.fragment_receiver.fragment_id: 3
component03_pull_standard.fragment_receiver.starting_fragment_id: 3
component03_pull_standard.fragment_receiver.board_id: 3
component03_pull_standard.fragment_receiver.random_seed: 3

component04_pull_standard: @local::component_pull_standard
component04_pull_standard.fragment_receiver.fragment_id: 4
component04_pull_standard.fragment_receiver.starting_fragment_id: 4
component04_pull_standard.fragment_receiver.board_id: 4
component04_pull_standard.fragment_receiver.random_seed: 4

component05_pull_standard: @local::component_pull_standard
component05_pull_standard.fragment_receiver.fragment_id: 5
component05_pull_standard.fragment_receiver.starting_fragment_id: 5
component05_pull_standard.fragment_receiver.board_id: 5
component05_pull_standard.fragment_receiver.random_seed: 5

component06_pull_standard: @local::component_pull_standard
component06_pull_standard.fragment_receiver.fragment_id: 6
component06_pull_standard.fragment_receiver.starting_fragment_id: 6
component06_pull_standard.fragment_receiver.board_id: 6
component06_pull_standard.fragment_receiver.random_seed: 6

component07_pull_standard: @local::component_pull_standard
component07_pull_standard.fragment_receiver.fragment_id: 7
component07_pull_standard.fragment_receiver.starting_fragment_id: 7
component07_pull_standard.fragment_receiver.board_id: 7
component07_pull_standard.fragment_receiver.random_seed: 7

component08_pull_standard: @local::component_pull_standard
component08_pull_standard.fragment_receiver.fragment_id: 8
component08_pull_standard.fragment_receiver.starting_fragment_id: 8
component08_pull_standard.fragment_receiver.board_id: 8
component08_pull_standard.fragment_receiver.random_seed: 8

component09_pull_standard: @local::component_pull_standard
component09_pull_standard.fragment_receiver.fragment_id: 9
component09_pull_standard.fragment_receiver.starting_fragment_id: 9
component09_pull_standard.fragment_receiver.board_id: 9
component09_pull_standard.fragment_receiver.random_seed: 9

component10_pull_standard: @local::component_pull_standard
component10_pull_standard.fragment_receiver.fragment_id: 10
component10_pull_standard.fragment_receiver.starting_fragment_id: 10
component10_pull_standard.fragment_receiver.board_id: 10
component10_pull_standard.fragment_receiver.random_seed: 10

END_PROLOG
